{"name":"Python-parallel-collections","tagline":"Python collections supporting parallel map/reduce style methods","body":"###Python Parallel Collections\r\n####Implementations of dict and list which support parallel map/reduce style operations\r\n\r\n####Who said Python was not setup for multicore computing? \r\nIn this package you'll find very simple parallel implementations of list and dict. The parallelism uses the [Python 2.7 backport](http://pythonhosted.org/futures/#processpoolexecutor-example) of the [concurrent.futures](http://docs.python.org/dev/library/concurrent.futures.html) package. If you can define your problem in terms of map/reduce/filter/flatten operations, it will run on several parallel Python processes on your machine, taking advantage of multiple cores. \r\nOtherwise these datastructures are equivalent to the non-parallel ones found in the standard library.\r\n\r\n####Getting Started\r\n`pip install python-parallel-collections`\r\n`from parallel.parallel_collections import ParallelList, ParallelDict`\r\n\r\n\r\n####Examples\r\n\r\n```python\r\n>>> def double(i):\r\n...     return i*2\r\n... \r\n>>> list_of_list =  ParallelList([[1,2,3],[4,5,6]])\r\n>>> flat_list = list_of_list.flatten()\r\n[1, 2, 3, 4, 5, 6]\r\n>>> list_of_list\r\n[[1, 2, 3], [4, 5, 6]]\r\n>>> flat_list.map(double)\r\n[2, 4, 6, 8, 10, 12]\r\n>>> list_of_list.flatmap(double)\r\n[2, 4, 6, 8, 10, 12]\r\n```\r\n\r\nAs you see every method call returns a new collection, instead of changing the current one.\r\nThe exception is the foreach method, which is equivalent to map but instead of returning a new collection it operates directly on the \r\ncurrent one and returns `None`.  \r\n```python\r\n>>> flat_list\r\n[1, 2, 3, 4, 5, 6]\r\n>>> flat_list.foreach(double)\r\nNone\r\n>>> flat_list\r\n[2, 4, 6, 8, 10, 12]\r\n```\r\n\r\nSince every operation (except foreach) returns a collection, these can be chained.\r\n```python\r\n>>> list_of_list =  ParallelList([[1,2,3],[4,5,6]])\r\n>>> list_of_list.flatmap(double).map(str)\r\n['2', '4', '6', '8', '10', '12']\r\n```\r\n\r\n####Regarding lambdas and closures\r\nSadly lambdas, closures and partial functions cannot be passed around multiple processes, so every function that you pass to the collection methods needs to be defined using the def statement. If you want the operation to carry extra state, use a class with a `__call__` method defined.\r\n```python\r\n>>> class multiply(object):\r\n...     def __init__(self, factor):\r\n...         self.factor = factor\r\n...     def __call__(self, item):\r\n...         return item * self.factor\r\n... \r\n>>> multiply(2)(3)\r\n6\r\n>>>list_of_list =  ParallelList([[1,2,3],[4,5,6]])\r\n>>> list_of_list.flatmap(multiply(2))\r\n[2, 4, 6, 8, 10, 12]\r\n```\r\n\r\n###Quick example of flatmap and filter for both collections\r\n\r\n####FlatMap\r\n\r\nFunctions passed to the flatmap method of a list will be passed every element in the list and should return a single element. For a dict, the function will receive a tuple (key, values) for every key in the dict, and should equally return a two element sequence.\r\n \r\n```python\r\n>>>def double(item):\r\n...    return item * 2\r\n...\r\n>>> list_of_list =  ParallelList([[1,2,3],[4,5,6]])\r\n>>> list_of_list.flatmap(double).map(str)\r\n['2', '4', '6', '8', '10', '12']\r\n>>> def double_dict(item):\r\n...     k,v = item\r\n...     try:\r\n...         return [k, [i *2 for i in v]]\r\n...     except TypeError:\r\n...         return [k, v * 2]\r\n... \r\n>>> d = ParallelDict(zip(range(2), [[[1,2],[3,4]],[3,4]]))\r\n>>> d\r\n{0: [[1, 2], [3, 4]], 1: [3, 4]}\r\n>>> flat_mapped = d.flatmap(double_dict)\r\n>>> flat_mapped\r\n{0: [2, 4, 6, 8], 1: [6, 8]}\r\n```\r\n\r\n####Reduce\r\nNote at this point reduce is not performed in parallel.\r\nReduce accepts an optional initializer, which will be passed as the first argument to every call to the function passed as reducer\r\n```python\r\n>>> def group_letters(all, letter):\r\n...     all[letter].append(letter)\r\n...     return all\r\n... \r\n>>>p = ParallelList(['a', 'a', 'b'])\r\n>>>reduced = p.reduce(group_letters, defaultdict(list))\r\n>>>reduced\r\n{'a': ['a', 'a'], 'b': ['b']}\r\n```\r\n\r\n####Filter\r\nThe Filter method should be passed a predicate, which means a function that will return True or False and will be called once for every element in the list and for every (key, values) in a dict.\r\n```python\r\n>>> def is_digit(item):\r\n...     return item.isdigit()\r\n...\r\n>>> p = ParallelList(['a','2','3'])\r\n>>> pred = is_digit\r\n>>> filtered = p.filter(pred)\r\n>>> filtered\r\n['2', '3']\r\n\r\n>>>def is_digit_dict(item):\r\n...    return item[1].isdigit()\r\n...\r\n>>>p = ParallelDict(zip(range(3), ['a','2', '3',]))\r\n>>>p\r\n{0: 'a', 1: '2', 2: '3'}\r\n>>>pred = is_digit_dict\r\n>>>filtered = p.filter(pred)\r\n>>>filtered\r\n{1: '2', 2: '3'}\r\n```","google":"UA-46017131-1","note":"Don't delete this file! It's used internally to help with page regeneration."}