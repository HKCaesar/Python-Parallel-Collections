{"name":"Python-parallel-collections","tagline":"Python collections supporting parallel map/reduce style methods","body":"###Python Parallel Collections\r\n####Implementations of dict and list which support parallel map/reduce style operations\r\n\r\n####Who said Python was not setup for multicore computing? \r\nIn this package you'll find very simple parallel implementations of list, string and dict and a generator. The parallelism uses the [Python 2.7 backport](http://pythonhosted.org/futures/#processpoolexecutor-example) of the [concurrent.futures](http://docs.python.org/dev/library/concurrent.futures.html) package. If you can define your problem in terms of map/reduce/filter operations, it will run on several parallel Python processes on your machine, taking advantage of multiple cores. \r\nOtherwise these datastructures are equivalent to the non-parallel ones found in the standard library.\r\n\r\nPlease note that although the below examples are written in interactive style, due to the nature of multiple processes they might not \r\nactually work in the interactive interpreter. \r\n\r\n####Getting Started\r\n```python\r\npip install python-parallel-collections\r\npip install futures\r\n```\r\n```python\r\nfrom parallel.parallel_collections import ParallelList, ParallelDict, ParallelString, ParellelGen\r\n```\r\n\r\n####Examples\r\n\r\n```python\r\n>>> def double(i):\r\n...     return i*2\r\n... \r\n>>> list_of_list =  ParallelList([[1,2,3],[4,5,6]])\r\n>>> flat_list = list_of_list.flatten()\r\n[1, 2, 3, 4, 5, 6]\r\n>>> list_of_list\r\n[[1, 2, 3], [4, 5, 6]]\r\n>>> flat_list.map(double)\r\n[2, 4, 6, 8, 10, 12]\r\n>>> list_of_list.flatmap(double)\r\n[2, 4, 6, 8, 10, 12]\r\n```\r\n\r\nAs you see every method call returns a new collection, instead of changing the current one.\r\nThe exception is the foreach method, which is equivalent to map but instead of returning a new collection it operates directly on the \r\ncurrent one and returns `None`.  \r\n```python\r\n>>> flat_list\r\n[1, 2, 3, 4, 5, 6]\r\n>>> flat_list.foreach(double)\r\nNone\r\n>>> flat_list\r\n[2, 4, 6, 8, 10, 12]\r\n```\r\n\r\nSince every operation (except foreach) returns a collection, these can be chained.\r\n```python\r\n>>> list_of_list =  ParallelList([[1,2,3],[4,5,6]])\r\n>>> list_of_list.flatmap(double).map(str)\r\n['2', '4', '6', '8', '10', '12']\r\n```\r\n\r\n####When to use the ParallelGen class?\r\nThe ParallelGen class should be used in the same cases that you would normally use a generator: to avoid the evaluation of an intermittent datastructure. With the parallel generator, you can chain map/filter/reduce calls without evaluating the entire datastructure on every operation, just like you would when building data processing pipelines using a chain of generator functions. Each element in the datastructure will be processed one by one. This is a great way to save memory and work with potentially large or infinite streams of data. \r\n\r\nThe below example illustrates this. Note each operation on the parallel list results in the entire list being evaluated before the next operation, while the generator allows every element go through each step before sending the next one in. \r\nAlso note the the generator will not result in anything happening unless you actually do something to evaluate it (such as the list comprehension does in the below example). \r\n\r\n```python\r\n>>> def _print(item):\r\n...     print item \r\n...     return item\r\n... \r\n>>> def double(item):\r\n...     return item * 2 \r\n... \r\n>>> plist = ParallelList(range(5))\r\n>>> [i for i in plist.map(double).map(_print).map(double).map(_print)]\r\n0\r\n2\r\n4\r\n6\r\n8\r\n0\r\n4\r\n8\r\n12\r\n16\r\n>>> pgen = ParallelGen(range(5))\r\n>>> [i for i in pgen.map(double).map(_print).map(double).map(_print)]\r\n0\r\n0\r\n2\r\n4\r\n4\r\n8\r\n6\r\n12\r\n8\r\n16\r\n```\r\n\r\n####Regarding lambdas and closures\r\nSadly lambdas, closures and partial functions cannot be passed around multiple processes, so every function that you pass to the collection methods needs to be defined using the def statement. If you want the operation to carry extra state, use a class with a `__call__` method defined.\r\n```python\r\n>>> class multiply(object):\r\n...     def __init__(self, factor):\r\n...         self.factor = factor\r\n...     def __call__(self, item):\r\n...         return item * self.factor\r\n... \r\n>>> multiply(2)(3)\r\n6\r\n>>> list_of_list =  ParallelList([[1,2,3],[4,5,6]])\r\n>>> list_of_list.flatmap(multiply(2))\r\n[2, 4, 6, 8, 10, 12]\r\n```\r\n\r\n###Quick examples of map, reduce and filter\r\n\r\n####Map and FlatMap\r\n\r\nFunctions passed to the map method of a list will be passed every element in the list and should return a single element. For a dict, the function will receive a tuple (key, values) for every key in the dict, and should equally return a two element sequence. Flatmap will first flatten the sequence then apply map to it.\r\n \r\n```python\r\n>>> def double(item):\r\n...    return item * 2\r\n...\r\n>>> list_of_list =  ParallelList([[1,2,3],[4,5,6]])\r\n>>> list_of_list.flatmap(double).map(str)\r\n['2', '4', '6', '8', '10', '12']\r\n>>> def double_dict(item):\r\n...     k,v = item\r\n...     try:\r\n...         return [k, [i *2 for i in v]]\r\n...     except TypeError:\r\n...         return [k, v * 2]\r\n... \r\n>>> d = ParallelDict(zip(range(2), [[[1,2],[3,4]],[3,4]]))\r\n>>> d\r\n{0: [[1, 2], [3, 4]], 1: [3, 4]}\r\n>>> flat_mapped = d.flatmap(double_dict)\r\n>>> flat_mapped\r\n{0: [2, 4, 6, 8], 1: [6, 8]}\r\n\r\n>>> def to_upper(item):\r\n...     return item.upper() \r\n... \r\n>>> p = ParallelString('qwerty')\r\n>>> mapped = p.map(to_upper)\r\n'QWERTY'\r\n```\r\n\r\n####Reduce\r\nReduce accepts an optional initializer, which will be passed as the first argument to every call to the function passed as reducer\r\n```python\r\n>>> def group_letters(all, letter):\r\n...     all[letter].append(letter)\r\n...     return all\r\n... \r\n>>> p = ParallelList(['a', 'a', 'b'])\r\n>>> reduced = p.reduce(group_letters, defaultdict(list))\r\n{'a': ['a', 'a'], 'b': ['b']}\r\n>>> p = ParallelString('aab')\r\n>>> p.reduce(group_letters, defaultdict(list))\r\n{'a': ['a', 'a'], 'b': ['b']}\r\n```\r\n\r\n####Filter\r\nThe Filter method should be passed a predicate, which means a function that will return True or False and will be called once for every element in the list and for every (key, values) in a dict.\r\n```python\r\n>>> def is_digit(item):\r\n...     return item.isdigit()\r\n...\r\n>>> p = ParallelList(['a','2','3'])\r\n>>> pred = is_digit\r\n>>> filtered = p.filter(pred)\r\n>>> filtered\r\n['2', '3']\r\n\r\n>>> def is_digit_dict(item):\r\n...    return item[1].isdigit()\r\n...\r\n>>> p = ParallelDict(zip(range(3), ['a','2', '3',]))\r\n{0: 'a', 1: '2', 2: '3'}\r\n>>> pred = is_digit_dict\r\n>>> filtered = p.filter(pred)\r\n>>> filtered\r\n{1: '2', 2: '3'}\r\n>>> p = ParallelString('a23')\r\n>>> p.filter(is_digit)\r\n'23'\r\n```","google":"UA-46017131-1","note":"Don't delete this file! It's used internally to help with page regeneration."}